// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'order.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

Order _$OrderFromJson(Map<String, dynamic> json) {
  return _Order.fromJson(json);
}

/// @nodoc
mixin _$Order {
  String get id =>
      throw _privateConstructorUsedError; // order ID generated by customer
  String get customerPubkey =>
      throw _privateConstructorUsedError; // customer's public key
  String get merchantPubkey =>
      throw _privateConstructorUsedError; // merchant's public key
  OrderStatus get status =>
      throw _privateConstructorUsedError; // current order status
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime? get updatedAt =>
      throw _privateConstructorUsedError; // Optional fields for tracking
  String? get stallId =>
      throw _privateConstructorUsedError; // which stall this order is for
  String? get stallName =>
      throw _privateConstructorUsedError; // cached stall name
  DateTime? get estimatedReady =>
      throw _privateConstructorUsedError; // when order will be ready
  String? get riderPubkey =>
      throw _privateConstructorUsedError; // assigned rider if any
  // Event references
  String? get statusEventId =>
      throw _privateConstructorUsedError; // public status event ID
  String? get detailsEventId =>
      throw _privateConstructorUsedError; // encrypted details event ID (kind 4)
  // Decrypted order details (loaded separately via NIP-04/NIP-44)
  OrderDetails? get details => throw _privateConstructorUsedError;

  /// Serializes this Order to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrderCopyWith<Order> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderCopyWith<$Res> {
  factory $OrderCopyWith(Order value, $Res Function(Order) then) =
      _$OrderCopyWithImpl<$Res, Order>;
  @useResult
  $Res call({
    String id,
    String customerPubkey,
    String merchantPubkey,
    OrderStatus status,
    DateTime createdAt,
    DateTime? updatedAt,
    String? stallId,
    String? stallName,
    DateTime? estimatedReady,
    String? riderPubkey,
    String? statusEventId,
    String? detailsEventId,
    OrderDetails? details,
  });

  $OrderDetailsCopyWith<$Res>? get details;
}

/// @nodoc
class _$OrderCopyWithImpl<$Res, $Val extends Order>
    implements $OrderCopyWith<$Res> {
  _$OrderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? customerPubkey = null,
    Object? merchantPubkey = null,
    Object? status = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? stallId = freezed,
    Object? stallName = freezed,
    Object? estimatedReady = freezed,
    Object? riderPubkey = freezed,
    Object? statusEventId = freezed,
    Object? detailsEventId = freezed,
    Object? details = freezed,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            customerPubkey: null == customerPubkey
                ? _value.customerPubkey
                : customerPubkey // ignore: cast_nullable_to_non_nullable
                      as String,
            merchantPubkey: null == merchantPubkey
                ? _value.merchantPubkey
                : merchantPubkey // ignore: cast_nullable_to_non_nullable
                      as String,
            status: null == status
                ? _value.status
                : status // ignore: cast_nullable_to_non_nullable
                      as OrderStatus,
            createdAt: null == createdAt
                ? _value.createdAt
                : createdAt // ignore: cast_nullable_to_non_nullable
                      as DateTime,
            updatedAt: freezed == updatedAt
                ? _value.updatedAt
                : updatedAt // ignore: cast_nullable_to_non_nullable
                      as DateTime?,
            stallId: freezed == stallId
                ? _value.stallId
                : stallId // ignore: cast_nullable_to_non_nullable
                      as String?,
            stallName: freezed == stallName
                ? _value.stallName
                : stallName // ignore: cast_nullable_to_non_nullable
                      as String?,
            estimatedReady: freezed == estimatedReady
                ? _value.estimatedReady
                : estimatedReady // ignore: cast_nullable_to_non_nullable
                      as DateTime?,
            riderPubkey: freezed == riderPubkey
                ? _value.riderPubkey
                : riderPubkey // ignore: cast_nullable_to_non_nullable
                      as String?,
            statusEventId: freezed == statusEventId
                ? _value.statusEventId
                : statusEventId // ignore: cast_nullable_to_non_nullable
                      as String?,
            detailsEventId: freezed == detailsEventId
                ? _value.detailsEventId
                : detailsEventId // ignore: cast_nullable_to_non_nullable
                      as String?,
            details: freezed == details
                ? _value.details
                : details // ignore: cast_nullable_to_non_nullable
                      as OrderDetails?,
          )
          as $Val,
    );
  }

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OrderDetailsCopyWith<$Res>? get details {
    if (_value.details == null) {
      return null;
    }

    return $OrderDetailsCopyWith<$Res>(_value.details!, (value) {
      return _then(_value.copyWith(details: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OrderImplCopyWith<$Res> implements $OrderCopyWith<$Res> {
  factory _$$OrderImplCopyWith(
    _$OrderImpl value,
    $Res Function(_$OrderImpl) then,
  ) = __$$OrderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    String customerPubkey,
    String merchantPubkey,
    OrderStatus status,
    DateTime createdAt,
    DateTime? updatedAt,
    String? stallId,
    String? stallName,
    DateTime? estimatedReady,
    String? riderPubkey,
    String? statusEventId,
    String? detailsEventId,
    OrderDetails? details,
  });

  @override
  $OrderDetailsCopyWith<$Res>? get details;
}

/// @nodoc
class __$$OrderImplCopyWithImpl<$Res>
    extends _$OrderCopyWithImpl<$Res, _$OrderImpl>
    implements _$$OrderImplCopyWith<$Res> {
  __$$OrderImplCopyWithImpl(
    _$OrderImpl _value,
    $Res Function(_$OrderImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? customerPubkey = null,
    Object? merchantPubkey = null,
    Object? status = null,
    Object? createdAt = null,
    Object? updatedAt = freezed,
    Object? stallId = freezed,
    Object? stallName = freezed,
    Object? estimatedReady = freezed,
    Object? riderPubkey = freezed,
    Object? statusEventId = freezed,
    Object? detailsEventId = freezed,
    Object? details = freezed,
  }) {
    return _then(
      _$OrderImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        customerPubkey: null == customerPubkey
            ? _value.customerPubkey
            : customerPubkey // ignore: cast_nullable_to_non_nullable
                  as String,
        merchantPubkey: null == merchantPubkey
            ? _value.merchantPubkey
            : merchantPubkey // ignore: cast_nullable_to_non_nullable
                  as String,
        status: null == status
            ? _value.status
            : status // ignore: cast_nullable_to_non_nullable
                  as OrderStatus,
        createdAt: null == createdAt
            ? _value.createdAt
            : createdAt // ignore: cast_nullable_to_non_nullable
                  as DateTime,
        updatedAt: freezed == updatedAt
            ? _value.updatedAt
            : updatedAt // ignore: cast_nullable_to_non_nullable
                  as DateTime?,
        stallId: freezed == stallId
            ? _value.stallId
            : stallId // ignore: cast_nullable_to_non_nullable
                  as String?,
        stallName: freezed == stallName
            ? _value.stallName
            : stallName // ignore: cast_nullable_to_non_nullable
                  as String?,
        estimatedReady: freezed == estimatedReady
            ? _value.estimatedReady
            : estimatedReady // ignore: cast_nullable_to_non_nullable
                  as DateTime?,
        riderPubkey: freezed == riderPubkey
            ? _value.riderPubkey
            : riderPubkey // ignore: cast_nullable_to_non_nullable
                  as String?,
        statusEventId: freezed == statusEventId
            ? _value.statusEventId
            : statusEventId // ignore: cast_nullable_to_non_nullable
                  as String?,
        detailsEventId: freezed == detailsEventId
            ? _value.detailsEventId
            : detailsEventId // ignore: cast_nullable_to_non_nullable
                  as String?,
        details: freezed == details
            ? _value.details
            : details // ignore: cast_nullable_to_non_nullable
                  as OrderDetails?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderImpl implements _Order {
  const _$OrderImpl({
    required this.id,
    required this.customerPubkey,
    required this.merchantPubkey,
    required this.status,
    required this.createdAt,
    this.updatedAt,
    this.stallId,
    this.stallName,
    this.estimatedReady,
    this.riderPubkey,
    this.statusEventId,
    this.detailsEventId,
    this.details,
  });

  factory _$OrderImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderImplFromJson(json);

  @override
  final String id;
  // order ID generated by customer
  @override
  final String customerPubkey;
  // customer's public key
  @override
  final String merchantPubkey;
  // merchant's public key
  @override
  final OrderStatus status;
  // current order status
  @override
  final DateTime createdAt;
  @override
  final DateTime? updatedAt;
  // Optional fields for tracking
  @override
  final String? stallId;
  // which stall this order is for
  @override
  final String? stallName;
  // cached stall name
  @override
  final DateTime? estimatedReady;
  // when order will be ready
  @override
  final String? riderPubkey;
  // assigned rider if any
  // Event references
  @override
  final String? statusEventId;
  // public status event ID
  @override
  final String? detailsEventId;
  // encrypted details event ID (kind 4)
  // Decrypted order details (loaded separately via NIP-04/NIP-44)
  @override
  final OrderDetails? details;

  @override
  String toString() {
    return 'Order(id: $id, customerPubkey: $customerPubkey, merchantPubkey: $merchantPubkey, status: $status, createdAt: $createdAt, updatedAt: $updatedAt, stallId: $stallId, stallName: $stallName, estimatedReady: $estimatedReady, riderPubkey: $riderPubkey, statusEventId: $statusEventId, detailsEventId: $detailsEventId, details: $details)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.customerPubkey, customerPubkey) ||
                other.customerPubkey == customerPubkey) &&
            (identical(other.merchantPubkey, merchantPubkey) ||
                other.merchantPubkey == merchantPubkey) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.stallId, stallId) || other.stallId == stallId) &&
            (identical(other.stallName, stallName) ||
                other.stallName == stallName) &&
            (identical(other.estimatedReady, estimatedReady) ||
                other.estimatedReady == estimatedReady) &&
            (identical(other.riderPubkey, riderPubkey) ||
                other.riderPubkey == riderPubkey) &&
            (identical(other.statusEventId, statusEventId) ||
                other.statusEventId == statusEventId) &&
            (identical(other.detailsEventId, detailsEventId) ||
                other.detailsEventId == detailsEventId) &&
            (identical(other.details, details) || other.details == details));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    customerPubkey,
    merchantPubkey,
    status,
    createdAt,
    updatedAt,
    stallId,
    stallName,
    estimatedReady,
    riderPubkey,
    statusEventId,
    detailsEventId,
    details,
  );

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderImplCopyWith<_$OrderImpl> get copyWith =>
      __$$OrderImplCopyWithImpl<_$OrderImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderImplToJson(this);
  }
}

abstract class _Order implements Order {
  const factory _Order({
    required final String id,
    required final String customerPubkey,
    required final String merchantPubkey,
    required final OrderStatus status,
    required final DateTime createdAt,
    final DateTime? updatedAt,
    final String? stallId,
    final String? stallName,
    final DateTime? estimatedReady,
    final String? riderPubkey,
    final String? statusEventId,
    final String? detailsEventId,
    final OrderDetails? details,
  }) = _$OrderImpl;

  factory _Order.fromJson(Map<String, dynamic> json) = _$OrderImpl.fromJson;

  @override
  String get id; // order ID generated by customer
  @override
  String get customerPubkey; // customer's public key
  @override
  String get merchantPubkey; // merchant's public key
  @override
  OrderStatus get status; // current order status
  @override
  DateTime get createdAt;
  @override
  DateTime? get updatedAt; // Optional fields for tracking
  @override
  String? get stallId; // which stall this order is for
  @override
  String? get stallName; // cached stall name
  @override
  DateTime? get estimatedReady; // when order will be ready
  @override
  String? get riderPubkey; // assigned rider if any
  // Event references
  @override
  String? get statusEventId; // public status event ID
  @override
  String? get detailsEventId; // encrypted details event ID (kind 4)
  // Decrypted order details (loaded separately via NIP-04/NIP-44)
  @override
  OrderDetails? get details;

  /// Create a copy of Order
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrderImplCopyWith<_$OrderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrderDetails _$OrderDetailsFromJson(Map<String, dynamic> json) {
  return _OrderDetails.fromJson(json);
}

/// @nodoc
mixin _$OrderDetails {
  String get id =>
      throw _privateConstructorUsedError; // order ID (same as Order.id)
  int get type =>
      throw _privateConstructorUsedError; // message type: 0 = new order
  String? get name =>
      throw _privateConstructorUsedError; // customer name (optional)
  String? get address =>
      throw _privateConstructorUsedError; // physical address for goods (optional)
  String? get message =>
      throw _privateConstructorUsedError; // message for merchant (optional)
  ContactInfo get contact =>
      throw _privateConstructorUsedError; // customer contact information
  List<OrderItem> get items =>
      throw _privateConstructorUsedError; // products being ordered
  String get shippingId =>
      throw _privateConstructorUsedError; // selected shipping zone ID
  // Additional fields for payment tracking
  String? get paymentHash =>
      throw _privateConstructorUsedError; // Lightning payment hash
  String? get paymentPreimage =>
      throw _privateConstructorUsedError; // Payment proof
  int? get total =>
      throw _privateConstructorUsedError; // total amount in smallest unit
  int? get subtotal => throw _privateConstructorUsedError; // items subtotal
  int? get shippingCost => throw _privateConstructorUsedError; // shipping cost
  int? get discount => throw _privateConstructorUsedError;

  /// Serializes this OrderDetails to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrderDetailsCopyWith<OrderDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderDetailsCopyWith<$Res> {
  factory $OrderDetailsCopyWith(
    OrderDetails value,
    $Res Function(OrderDetails) then,
  ) = _$OrderDetailsCopyWithImpl<$Res, OrderDetails>;
  @useResult
  $Res call({
    String id,
    int type,
    String? name,
    String? address,
    String? message,
    ContactInfo contact,
    List<OrderItem> items,
    String shippingId,
    String? paymentHash,
    String? paymentPreimage,
    int? total,
    int? subtotal,
    int? shippingCost,
    int? discount,
  });

  $ContactInfoCopyWith<$Res> get contact;
}

/// @nodoc
class _$OrderDetailsCopyWithImpl<$Res, $Val extends OrderDetails>
    implements $OrderDetailsCopyWith<$Res> {
  _$OrderDetailsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? name = freezed,
    Object? address = freezed,
    Object? message = freezed,
    Object? contact = null,
    Object? items = null,
    Object? shippingId = null,
    Object? paymentHash = freezed,
    Object? paymentPreimage = freezed,
    Object? total = freezed,
    Object? subtotal = freezed,
    Object? shippingCost = freezed,
    Object? discount = freezed,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as int,
            name: freezed == name
                ? _value.name
                : name // ignore: cast_nullable_to_non_nullable
                      as String?,
            address: freezed == address
                ? _value.address
                : address // ignore: cast_nullable_to_non_nullable
                      as String?,
            message: freezed == message
                ? _value.message
                : message // ignore: cast_nullable_to_non_nullable
                      as String?,
            contact: null == contact
                ? _value.contact
                : contact // ignore: cast_nullable_to_non_nullable
                      as ContactInfo,
            items: null == items
                ? _value.items
                : items // ignore: cast_nullable_to_non_nullable
                      as List<OrderItem>,
            shippingId: null == shippingId
                ? _value.shippingId
                : shippingId // ignore: cast_nullable_to_non_nullable
                      as String,
            paymentHash: freezed == paymentHash
                ? _value.paymentHash
                : paymentHash // ignore: cast_nullable_to_non_nullable
                      as String?,
            paymentPreimage: freezed == paymentPreimage
                ? _value.paymentPreimage
                : paymentPreimage // ignore: cast_nullable_to_non_nullable
                      as String?,
            total: freezed == total
                ? _value.total
                : total // ignore: cast_nullable_to_non_nullable
                      as int?,
            subtotal: freezed == subtotal
                ? _value.subtotal
                : subtotal // ignore: cast_nullable_to_non_nullable
                      as int?,
            shippingCost: freezed == shippingCost
                ? _value.shippingCost
                : shippingCost // ignore: cast_nullable_to_non_nullable
                      as int?,
            discount: freezed == discount
                ? _value.discount
                : discount // ignore: cast_nullable_to_non_nullable
                      as int?,
          )
          as $Val,
    );
  }

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ContactInfoCopyWith<$Res> get contact {
    return $ContactInfoCopyWith<$Res>(_value.contact, (value) {
      return _then(_value.copyWith(contact: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$OrderDetailsImplCopyWith<$Res>
    implements $OrderDetailsCopyWith<$Res> {
  factory _$$OrderDetailsImplCopyWith(
    _$OrderDetailsImpl value,
    $Res Function(_$OrderDetailsImpl) then,
  ) = __$$OrderDetailsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    int type,
    String? name,
    String? address,
    String? message,
    ContactInfo contact,
    List<OrderItem> items,
    String shippingId,
    String? paymentHash,
    String? paymentPreimage,
    int? total,
    int? subtotal,
    int? shippingCost,
    int? discount,
  });

  @override
  $ContactInfoCopyWith<$Res> get contact;
}

/// @nodoc
class __$$OrderDetailsImplCopyWithImpl<$Res>
    extends _$OrderDetailsCopyWithImpl<$Res, _$OrderDetailsImpl>
    implements _$$OrderDetailsImplCopyWith<$Res> {
  __$$OrderDetailsImplCopyWithImpl(
    _$OrderDetailsImpl _value,
    $Res Function(_$OrderDetailsImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? name = freezed,
    Object? address = freezed,
    Object? message = freezed,
    Object? contact = null,
    Object? items = null,
    Object? shippingId = null,
    Object? paymentHash = freezed,
    Object? paymentPreimage = freezed,
    Object? total = freezed,
    Object? subtotal = freezed,
    Object? shippingCost = freezed,
    Object? discount = freezed,
  }) {
    return _then(
      _$OrderDetailsImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as int,
        name: freezed == name
            ? _value.name
            : name // ignore: cast_nullable_to_non_nullable
                  as String?,
        address: freezed == address
            ? _value.address
            : address // ignore: cast_nullable_to_non_nullable
                  as String?,
        message: freezed == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String?,
        contact: null == contact
            ? _value.contact
            : contact // ignore: cast_nullable_to_non_nullable
                  as ContactInfo,
        items: null == items
            ? _value._items
            : items // ignore: cast_nullable_to_non_nullable
                  as List<OrderItem>,
        shippingId: null == shippingId
            ? _value.shippingId
            : shippingId // ignore: cast_nullable_to_non_nullable
                  as String,
        paymentHash: freezed == paymentHash
            ? _value.paymentHash
            : paymentHash // ignore: cast_nullable_to_non_nullable
                  as String?,
        paymentPreimage: freezed == paymentPreimage
            ? _value.paymentPreimage
            : paymentPreimage // ignore: cast_nullable_to_non_nullable
                  as String?,
        total: freezed == total
            ? _value.total
            : total // ignore: cast_nullable_to_non_nullable
                  as int?,
        subtotal: freezed == subtotal
            ? _value.subtotal
            : subtotal // ignore: cast_nullable_to_non_nullable
                  as int?,
        shippingCost: freezed == shippingCost
            ? _value.shippingCost
            : shippingCost // ignore: cast_nullable_to_non_nullable
                  as int?,
        discount: freezed == discount
            ? _value.discount
            : discount // ignore: cast_nullable_to_non_nullable
                  as int?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderDetailsImpl implements _OrderDetails {
  const _$OrderDetailsImpl({
    required this.id,
    this.type = 0,
    this.name,
    this.address,
    this.message,
    required this.contact,
    required final List<OrderItem> items,
    required this.shippingId,
    this.paymentHash,
    this.paymentPreimage,
    this.total,
    this.subtotal,
    this.shippingCost,
    this.discount,
  }) : _items = items;

  factory _$OrderDetailsImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderDetailsImplFromJson(json);

  @override
  final String id;
  // order ID (same as Order.id)
  @override
  @JsonKey()
  final int type;
  // message type: 0 = new order
  @override
  final String? name;
  // customer name (optional)
  @override
  final String? address;
  // physical address for goods (optional)
  @override
  final String? message;
  // message for merchant (optional)
  @override
  final ContactInfo contact;
  // customer contact information
  final List<OrderItem> _items;
  // customer contact information
  @override
  List<OrderItem> get items {
    if (_items is EqualUnmodifiableListView) return _items;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_items);
  }

  // products being ordered
  @override
  final String shippingId;
  // selected shipping zone ID
  // Additional fields for payment tracking
  @override
  final String? paymentHash;
  // Lightning payment hash
  @override
  final String? paymentPreimage;
  // Payment proof
  @override
  final int? total;
  // total amount in smallest unit
  @override
  final int? subtotal;
  // items subtotal
  @override
  final int? shippingCost;
  // shipping cost
  @override
  final int? discount;

  @override
  String toString() {
    return 'OrderDetails(id: $id, type: $type, name: $name, address: $address, message: $message, contact: $contact, items: $items, shippingId: $shippingId, paymentHash: $paymentHash, paymentPreimage: $paymentPreimage, total: $total, subtotal: $subtotal, shippingCost: $shippingCost, discount: $discount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderDetailsImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.address, address) || other.address == address) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.contact, contact) || other.contact == contact) &&
            const DeepCollectionEquality().equals(other._items, _items) &&
            (identical(other.shippingId, shippingId) ||
                other.shippingId == shippingId) &&
            (identical(other.paymentHash, paymentHash) ||
                other.paymentHash == paymentHash) &&
            (identical(other.paymentPreimage, paymentPreimage) ||
                other.paymentPreimage == paymentPreimage) &&
            (identical(other.total, total) || other.total == total) &&
            (identical(other.subtotal, subtotal) ||
                other.subtotal == subtotal) &&
            (identical(other.shippingCost, shippingCost) ||
                other.shippingCost == shippingCost) &&
            (identical(other.discount, discount) ||
                other.discount == discount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    type,
    name,
    address,
    message,
    contact,
    const DeepCollectionEquality().hash(_items),
    shippingId,
    paymentHash,
    paymentPreimage,
    total,
    subtotal,
    shippingCost,
    discount,
  );

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderDetailsImplCopyWith<_$OrderDetailsImpl> get copyWith =>
      __$$OrderDetailsImplCopyWithImpl<_$OrderDetailsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderDetailsImplToJson(this);
  }
}

abstract class _OrderDetails implements OrderDetails {
  const factory _OrderDetails({
    required final String id,
    final int type,
    final String? name,
    final String? address,
    final String? message,
    required final ContactInfo contact,
    required final List<OrderItem> items,
    required final String shippingId,
    final String? paymentHash,
    final String? paymentPreimage,
    final int? total,
    final int? subtotal,
    final int? shippingCost,
    final int? discount,
  }) = _$OrderDetailsImpl;

  factory _OrderDetails.fromJson(Map<String, dynamic> json) =
      _$OrderDetailsImpl.fromJson;

  @override
  String get id; // order ID (same as Order.id)
  @override
  int get type; // message type: 0 = new order
  @override
  String? get name; // customer name (optional)
  @override
  String? get address; // physical address for goods (optional)
  @override
  String? get message; // message for merchant (optional)
  @override
  ContactInfo get contact; // customer contact information
  @override
  List<OrderItem> get items; // products being ordered
  @override
  String get shippingId; // selected shipping zone ID
  // Additional fields for payment tracking
  @override
  String? get paymentHash; // Lightning payment hash
  @override
  String? get paymentPreimage; // Payment proof
  @override
  int? get total; // total amount in smallest unit
  @override
  int? get subtotal; // items subtotal
  @override
  int? get shippingCost; // shipping cost
  @override
  int? get discount;

  /// Create a copy of OrderDetails
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrderDetailsImplCopyWith<_$OrderDetailsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

ContactInfo _$ContactInfoFromJson(Map<String, dynamic> json) {
  return _ContactInfo.fromJson(json);
}

/// @nodoc
mixin _$ContactInfo {
  String get nostr =>
      throw _privateConstructorUsedError; // 32-bytes hex pubkey (required in spec)
  String? get phone =>
      throw _privateConstructorUsedError; // phone number if customer wants phone contact
  String? get email => throw _privateConstructorUsedError;

  /// Serializes this ContactInfo to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ContactInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ContactInfoCopyWith<ContactInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ContactInfoCopyWith<$Res> {
  factory $ContactInfoCopyWith(
    ContactInfo value,
    $Res Function(ContactInfo) then,
  ) = _$ContactInfoCopyWithImpl<$Res, ContactInfo>;
  @useResult
  $Res call({String nostr, String? phone, String? email});
}

/// @nodoc
class _$ContactInfoCopyWithImpl<$Res, $Val extends ContactInfo>
    implements $ContactInfoCopyWith<$Res> {
  _$ContactInfoCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ContactInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nostr = null,
    Object? phone = freezed,
    Object? email = freezed,
  }) {
    return _then(
      _value.copyWith(
            nostr: null == nostr
                ? _value.nostr
                : nostr // ignore: cast_nullable_to_non_nullable
                      as String,
            phone: freezed == phone
                ? _value.phone
                : phone // ignore: cast_nullable_to_non_nullable
                      as String?,
            email: freezed == email
                ? _value.email
                : email // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$ContactInfoImplCopyWith<$Res>
    implements $ContactInfoCopyWith<$Res> {
  factory _$$ContactInfoImplCopyWith(
    _$ContactInfoImpl value,
    $Res Function(_$ContactInfoImpl) then,
  ) = __$$ContactInfoImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String nostr, String? phone, String? email});
}

/// @nodoc
class __$$ContactInfoImplCopyWithImpl<$Res>
    extends _$ContactInfoCopyWithImpl<$Res, _$ContactInfoImpl>
    implements _$$ContactInfoImplCopyWith<$Res> {
  __$$ContactInfoImplCopyWithImpl(
    _$ContactInfoImpl _value,
    $Res Function(_$ContactInfoImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of ContactInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? nostr = null,
    Object? phone = freezed,
    Object? email = freezed,
  }) {
    return _then(
      _$ContactInfoImpl(
        nostr: null == nostr
            ? _value.nostr
            : nostr // ignore: cast_nullable_to_non_nullable
                  as String,
        phone: freezed == phone
            ? _value.phone
            : phone // ignore: cast_nullable_to_non_nullable
                  as String?,
        email: freezed == email
            ? _value.email
            : email // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$ContactInfoImpl implements _ContactInfo {
  const _$ContactInfoImpl({required this.nostr, this.phone, this.email});

  factory _$ContactInfoImpl.fromJson(Map<String, dynamic> json) =>
      _$$ContactInfoImplFromJson(json);

  @override
  final String nostr;
  // 32-bytes hex pubkey (required in spec)
  @override
  final String? phone;
  // phone number if customer wants phone contact
  @override
  final String? email;

  @override
  String toString() {
    return 'ContactInfo(nostr: $nostr, phone: $phone, email: $email)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ContactInfoImpl &&
            (identical(other.nostr, nostr) || other.nostr == nostr) &&
            (identical(other.phone, phone) || other.phone == phone) &&
            (identical(other.email, email) || other.email == email));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, nostr, phone, email);

  /// Create a copy of ContactInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ContactInfoImplCopyWith<_$ContactInfoImpl> get copyWith =>
      __$$ContactInfoImplCopyWithImpl<_$ContactInfoImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ContactInfoImplToJson(this);
  }
}

abstract class _ContactInfo implements ContactInfo {
  const factory _ContactInfo({
    required final String nostr,
    final String? phone,
    final String? email,
  }) = _$ContactInfoImpl;

  factory _ContactInfo.fromJson(Map<String, dynamic> json) =
      _$ContactInfoImpl.fromJson;

  @override
  String get nostr; // 32-bytes hex pubkey (required in spec)
  @override
  String? get phone; // phone number if customer wants phone contact
  @override
  String? get email;

  /// Create a copy of ContactInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ContactInfoImplCopyWith<_$ContactInfoImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrderItem _$OrderItemFromJson(Map<String, dynamic> json) {
  return _OrderItem.fromJson(json);
}

/// @nodoc
mixin _$OrderItem {
  String get productId =>
      throw _privateConstructorUsedError; // reference to product
  int get quantity => throw _privateConstructorUsedError; // how many units
  // Cached for display (not in NIP-15 spec but useful)
  String? get productName => throw _privateConstructorUsedError;
  double? get price => throw _privateConstructorUsedError; // price per unit
  Map<String, dynamic>? get customization =>
      throw _privateConstructorUsedError; // product customization
  String? get notes => throw _privateConstructorUsedError;

  /// Serializes this OrderItem to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrderItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrderItemCopyWith<OrderItem> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderItemCopyWith<$Res> {
  factory $OrderItemCopyWith(OrderItem value, $Res Function(OrderItem) then) =
      _$OrderItemCopyWithImpl<$Res, OrderItem>;
  @useResult
  $Res call({
    String productId,
    int quantity,
    String? productName,
    double? price,
    Map<String, dynamic>? customization,
    String? notes,
  });
}

/// @nodoc
class _$OrderItemCopyWithImpl<$Res, $Val extends OrderItem>
    implements $OrderItemCopyWith<$Res> {
  _$OrderItemCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrderItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? quantity = null,
    Object? productName = freezed,
    Object? price = freezed,
    Object? customization = freezed,
    Object? notes = freezed,
  }) {
    return _then(
      _value.copyWith(
            productId: null == productId
                ? _value.productId
                : productId // ignore: cast_nullable_to_non_nullable
                      as String,
            quantity: null == quantity
                ? _value.quantity
                : quantity // ignore: cast_nullable_to_non_nullable
                      as int,
            productName: freezed == productName
                ? _value.productName
                : productName // ignore: cast_nullable_to_non_nullable
                      as String?,
            price: freezed == price
                ? _value.price
                : price // ignore: cast_nullable_to_non_nullable
                      as double?,
            customization: freezed == customization
                ? _value.customization
                : customization // ignore: cast_nullable_to_non_nullable
                      as Map<String, dynamic>?,
            notes: freezed == notes
                ? _value.notes
                : notes // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$OrderItemImplCopyWith<$Res>
    implements $OrderItemCopyWith<$Res> {
  factory _$$OrderItemImplCopyWith(
    _$OrderItemImpl value,
    $Res Function(_$OrderItemImpl) then,
  ) = __$$OrderItemImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String productId,
    int quantity,
    String? productName,
    double? price,
    Map<String, dynamic>? customization,
    String? notes,
  });
}

/// @nodoc
class __$$OrderItemImplCopyWithImpl<$Res>
    extends _$OrderItemCopyWithImpl<$Res, _$OrderItemImpl>
    implements _$$OrderItemImplCopyWith<$Res> {
  __$$OrderItemImplCopyWithImpl(
    _$OrderItemImpl _value,
    $Res Function(_$OrderItemImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrderItem
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? productId = null,
    Object? quantity = null,
    Object? productName = freezed,
    Object? price = freezed,
    Object? customization = freezed,
    Object? notes = freezed,
  }) {
    return _then(
      _$OrderItemImpl(
        productId: null == productId
            ? _value.productId
            : productId // ignore: cast_nullable_to_non_nullable
                  as String,
        quantity: null == quantity
            ? _value.quantity
            : quantity // ignore: cast_nullable_to_non_nullable
                  as int,
        productName: freezed == productName
            ? _value.productName
            : productName // ignore: cast_nullable_to_non_nullable
                  as String?,
        price: freezed == price
            ? _value.price
            : price // ignore: cast_nullable_to_non_nullable
                  as double?,
        customization: freezed == customization
            ? _value._customization
            : customization // ignore: cast_nullable_to_non_nullable
                  as Map<String, dynamic>?,
        notes: freezed == notes
            ? _value.notes
            : notes // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderItemImpl implements _OrderItem {
  const _$OrderItemImpl({
    required this.productId,
    required this.quantity,
    this.productName,
    this.price,
    final Map<String, dynamic>? customization,
    this.notes,
  }) : _customization = customization;

  factory _$OrderItemImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderItemImplFromJson(json);

  @override
  final String productId;
  // reference to product
  @override
  final int quantity;
  // how many units
  // Cached for display (not in NIP-15 spec but useful)
  @override
  final String? productName;
  @override
  final double? price;
  // price per unit
  final Map<String, dynamic>? _customization;
  // price per unit
  @override
  Map<String, dynamic>? get customization {
    final value = _customization;
    if (value == null) return null;
    if (_customization is EqualUnmodifiableMapView) return _customization;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(value);
  }

  // product customization
  @override
  final String? notes;

  @override
  String toString() {
    return 'OrderItem(productId: $productId, quantity: $quantity, productName: $productName, price: $price, customization: $customization, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderItemImpl &&
            (identical(other.productId, productId) ||
                other.productId == productId) &&
            (identical(other.quantity, quantity) ||
                other.quantity == quantity) &&
            (identical(other.productName, productName) ||
                other.productName == productName) &&
            (identical(other.price, price) || other.price == price) &&
            const DeepCollectionEquality().equals(
              other._customization,
              _customization,
            ) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    productId,
    quantity,
    productName,
    price,
    const DeepCollectionEquality().hash(_customization),
    notes,
  );

  /// Create a copy of OrderItem
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderItemImplCopyWith<_$OrderItemImpl> get copyWith =>
      __$$OrderItemImplCopyWithImpl<_$OrderItemImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderItemImplToJson(this);
  }
}

abstract class _OrderItem implements OrderItem {
  const factory _OrderItem({
    required final String productId,
    required final int quantity,
    final String? productName,
    final double? price,
    final Map<String, dynamic>? customization,
    final String? notes,
  }) = _$OrderItemImpl;

  factory _OrderItem.fromJson(Map<String, dynamic> json) =
      _$OrderItemImpl.fromJson;

  @override
  String get productId; // reference to product
  @override
  int get quantity; // how many units
  // Cached for display (not in NIP-15 spec but useful)
  @override
  String? get productName;
  @override
  double? get price; // price per unit
  @override
  Map<String, dynamic>? get customization; // product customization
  @override
  String? get notes;

  /// Create a copy of OrderItem
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrderItemImplCopyWith<_$OrderItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PaymentRequest _$PaymentRequestFromJson(Map<String, dynamic> json) {
  return _PaymentRequest.fromJson(json);
}

/// @nodoc
mixin _$PaymentRequest {
  String get id => throw _privateConstructorUsedError; // order ID
  int get type =>
      throw _privateConstructorUsedError; // message type: 1 = payment request
  String? get message =>
      throw _privateConstructorUsedError; // message to customer (optional)
  List<PaymentOption> get paymentOptions => throw _privateConstructorUsedError;

  /// Serializes this PaymentRequest to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PaymentRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PaymentRequestCopyWith<PaymentRequest> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentRequestCopyWith<$Res> {
  factory $PaymentRequestCopyWith(
    PaymentRequest value,
    $Res Function(PaymentRequest) then,
  ) = _$PaymentRequestCopyWithImpl<$Res, PaymentRequest>;
  @useResult
  $Res call({
    String id,
    int type,
    String? message,
    List<PaymentOption> paymentOptions,
  });
}

/// @nodoc
class _$PaymentRequestCopyWithImpl<$Res, $Val extends PaymentRequest>
    implements $PaymentRequestCopyWith<$Res> {
  _$PaymentRequestCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = freezed,
    Object? paymentOptions = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as int,
            message: freezed == message
                ? _value.message
                : message // ignore: cast_nullable_to_non_nullable
                      as String?,
            paymentOptions: null == paymentOptions
                ? _value.paymentOptions
                : paymentOptions // ignore: cast_nullable_to_non_nullable
                      as List<PaymentOption>,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$PaymentRequestImplCopyWith<$Res>
    implements $PaymentRequestCopyWith<$Res> {
  factory _$$PaymentRequestImplCopyWith(
    _$PaymentRequestImpl value,
    $Res Function(_$PaymentRequestImpl) then,
  ) = __$$PaymentRequestImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String id,
    int type,
    String? message,
    List<PaymentOption> paymentOptions,
  });
}

/// @nodoc
class __$$PaymentRequestImplCopyWithImpl<$Res>
    extends _$PaymentRequestCopyWithImpl<$Res, _$PaymentRequestImpl>
    implements _$$PaymentRequestImplCopyWith<$Res> {
  __$$PaymentRequestImplCopyWithImpl(
    _$PaymentRequestImpl _value,
    $Res Function(_$PaymentRequestImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PaymentRequest
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = freezed,
    Object? paymentOptions = null,
  }) {
    return _then(
      _$PaymentRequestImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as int,
        message: freezed == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String?,
        paymentOptions: null == paymentOptions
            ? _value._paymentOptions
            : paymentOptions // ignore: cast_nullable_to_non_nullable
                  as List<PaymentOption>,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$PaymentRequestImpl implements _PaymentRequest {
  const _$PaymentRequestImpl({
    required this.id,
    this.type = 1,
    this.message,
    final List<PaymentOption> paymentOptions = const [],
  }) : _paymentOptions = paymentOptions;

  factory _$PaymentRequestImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentRequestImplFromJson(json);

  @override
  final String id;
  // order ID
  @override
  @JsonKey()
  final int type;
  // message type: 1 = payment request
  @override
  final String? message;
  // message to customer (optional)
  final List<PaymentOption> _paymentOptions;
  // message to customer (optional)
  @override
  @JsonKey()
  List<PaymentOption> get paymentOptions {
    if (_paymentOptions is EqualUnmodifiableListView) return _paymentOptions;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_paymentOptions);
  }

  @override
  String toString() {
    return 'PaymentRequest(id: $id, type: $type, message: $message, paymentOptions: $paymentOptions)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentRequestImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(
              other._paymentOptions,
              _paymentOptions,
            ));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    id,
    type,
    message,
    const DeepCollectionEquality().hash(_paymentOptions),
  );

  /// Create a copy of PaymentRequest
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentRequestImplCopyWith<_$PaymentRequestImpl> get copyWith =>
      __$$PaymentRequestImplCopyWithImpl<_$PaymentRequestImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentRequestImplToJson(this);
  }
}

abstract class _PaymentRequest implements PaymentRequest {
  const factory _PaymentRequest({
    required final String id,
    final int type,
    final String? message,
    final List<PaymentOption> paymentOptions,
  }) = _$PaymentRequestImpl;

  factory _PaymentRequest.fromJson(Map<String, dynamic> json) =
      _$PaymentRequestImpl.fromJson;

  @override
  String get id; // order ID
  @override
  int get type; // message type: 1 = payment request
  @override
  String? get message; // message to customer (optional)
  @override
  List<PaymentOption> get paymentOptions;

  /// Create a copy of PaymentRequest
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PaymentRequestImplCopyWith<_$PaymentRequestImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PaymentOption _$PaymentOptionFromJson(Map<String, dynamic> json) {
  return _PaymentOption.fromJson(json);
}

/// @nodoc
mixin _$PaymentOption {
  String get type => throw _privateConstructorUsedError; // url, btc, ln, lnurl
  String get link => throw _privateConstructorUsedError;

  /// Serializes this PaymentOption to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PaymentOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PaymentOptionCopyWith<PaymentOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PaymentOptionCopyWith<$Res> {
  factory $PaymentOptionCopyWith(
    PaymentOption value,
    $Res Function(PaymentOption) then,
  ) = _$PaymentOptionCopyWithImpl<$Res, PaymentOption>;
  @useResult
  $Res call({String type, String link});
}

/// @nodoc
class _$PaymentOptionCopyWithImpl<$Res, $Val extends PaymentOption>
    implements $PaymentOptionCopyWith<$Res> {
  _$PaymentOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PaymentOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? type = null, Object? link = null}) {
    return _then(
      _value.copyWith(
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as String,
            link: null == link
                ? _value.link
                : link // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$PaymentOptionImplCopyWith<$Res>
    implements $PaymentOptionCopyWith<$Res> {
  factory _$$PaymentOptionImplCopyWith(
    _$PaymentOptionImpl value,
    $Res Function(_$PaymentOptionImpl) then,
  ) = __$$PaymentOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String type, String link});
}

/// @nodoc
class __$$PaymentOptionImplCopyWithImpl<$Res>
    extends _$PaymentOptionCopyWithImpl<$Res, _$PaymentOptionImpl>
    implements _$$PaymentOptionImplCopyWith<$Res> {
  __$$PaymentOptionImplCopyWithImpl(
    _$PaymentOptionImpl _value,
    $Res Function(_$PaymentOptionImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of PaymentOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({Object? type = null, Object? link = null}) {
    return _then(
      _$PaymentOptionImpl(
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as String,
        link: null == link
            ? _value.link
            : link // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$PaymentOptionImpl implements _PaymentOption {
  const _$PaymentOptionImpl({required this.type, required this.link});

  factory _$PaymentOptionImpl.fromJson(Map<String, dynamic> json) =>
      _$$PaymentOptionImplFromJson(json);

  @override
  final String type;
  // url, btc, ln, lnurl
  @override
  final String link;

  @override
  String toString() {
    return 'PaymentOption(type: $type, link: $link)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentOptionImpl &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.link, link) || other.link == link));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, type, link);

  /// Create a copy of PaymentOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentOptionImplCopyWith<_$PaymentOptionImpl> get copyWith =>
      __$$PaymentOptionImplCopyWithImpl<_$PaymentOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PaymentOptionImplToJson(this);
  }
}

abstract class _PaymentOption implements PaymentOption {
  const factory _PaymentOption({
    required final String type,
    required final String link,
  }) = _$PaymentOptionImpl;

  factory _PaymentOption.fromJson(Map<String, dynamic> json) =
      _$PaymentOptionImpl.fromJson;

  @override
  String get type; // url, btc, ln, lnurl
  @override
  String get link;

  /// Create a copy of PaymentOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PaymentOptionImplCopyWith<_$PaymentOptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

OrderStatusUpdate _$OrderStatusUpdateFromJson(Map<String, dynamic> json) {
  return _OrderStatusUpdate.fromJson(json);
}

/// @nodoc
mixin _$OrderStatusUpdate {
  String get id => throw _privateConstructorUsedError; // order ID
  int get type =>
      throw _privateConstructorUsedError; // message type: 2 = status update
  String? get message =>
      throw _privateConstructorUsedError; // message to customer
  bool get paid => throw _privateConstructorUsedError; // has received payment
  bool get shipped => throw _privateConstructorUsedError;

  /// Serializes this OrderStatusUpdate to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of OrderStatusUpdate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OrderStatusUpdateCopyWith<OrderStatusUpdate> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OrderStatusUpdateCopyWith<$Res> {
  factory $OrderStatusUpdateCopyWith(
    OrderStatusUpdate value,
    $Res Function(OrderStatusUpdate) then,
  ) = _$OrderStatusUpdateCopyWithImpl<$Res, OrderStatusUpdate>;
  @useResult
  $Res call({String id, int type, String? message, bool paid, bool shipped});
}

/// @nodoc
class _$OrderStatusUpdateCopyWithImpl<$Res, $Val extends OrderStatusUpdate>
    implements $OrderStatusUpdateCopyWith<$Res> {
  _$OrderStatusUpdateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OrderStatusUpdate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = freezed,
    Object? paid = null,
    Object? shipped = null,
  }) {
    return _then(
      _value.copyWith(
            id: null == id
                ? _value.id
                : id // ignore: cast_nullable_to_non_nullable
                      as String,
            type: null == type
                ? _value.type
                : type // ignore: cast_nullable_to_non_nullable
                      as int,
            message: freezed == message
                ? _value.message
                : message // ignore: cast_nullable_to_non_nullable
                      as String?,
            paid: null == paid
                ? _value.paid
                : paid // ignore: cast_nullable_to_non_nullable
                      as bool,
            shipped: null == shipped
                ? _value.shipped
                : shipped // ignore: cast_nullable_to_non_nullable
                      as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$OrderStatusUpdateImplCopyWith<$Res>
    implements $OrderStatusUpdateCopyWith<$Res> {
  factory _$$OrderStatusUpdateImplCopyWith(
    _$OrderStatusUpdateImpl value,
    $Res Function(_$OrderStatusUpdateImpl) then,
  ) = __$$OrderStatusUpdateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String id, int type, String? message, bool paid, bool shipped});
}

/// @nodoc
class __$$OrderStatusUpdateImplCopyWithImpl<$Res>
    extends _$OrderStatusUpdateCopyWithImpl<$Res, _$OrderStatusUpdateImpl>
    implements _$$OrderStatusUpdateImplCopyWith<$Res> {
  __$$OrderStatusUpdateImplCopyWithImpl(
    _$OrderStatusUpdateImpl _value,
    $Res Function(_$OrderStatusUpdateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of OrderStatusUpdate
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? message = freezed,
    Object? paid = null,
    Object? shipped = null,
  }) {
    return _then(
      _$OrderStatusUpdateImpl(
        id: null == id
            ? _value.id
            : id // ignore: cast_nullable_to_non_nullable
                  as String,
        type: null == type
            ? _value.type
            : type // ignore: cast_nullable_to_non_nullable
                  as int,
        message: freezed == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String?,
        paid: null == paid
            ? _value.paid
            : paid // ignore: cast_nullable_to_non_nullable
                  as bool,
        shipped: null == shipped
            ? _value.shipped
            : shipped // ignore: cast_nullable_to_non_nullable
                  as bool,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$OrderStatusUpdateImpl implements _OrderStatusUpdate {
  const _$OrderStatusUpdateImpl({
    required this.id,
    this.type = 2,
    this.message,
    required this.paid,
    required this.shipped,
  });

  factory _$OrderStatusUpdateImpl.fromJson(Map<String, dynamic> json) =>
      _$$OrderStatusUpdateImplFromJson(json);

  @override
  final String id;
  // order ID
  @override
  @JsonKey()
  final int type;
  // message type: 2 = status update
  @override
  final String? message;
  // message to customer
  @override
  final bool paid;
  // has received payment
  @override
  final bool shipped;

  @override
  String toString() {
    return 'OrderStatusUpdate(id: $id, type: $type, message: $message, paid: $paid, shipped: $shipped)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OrderStatusUpdateImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.message, message) || other.message == message) &&
            (identical(other.paid, paid) || other.paid == paid) &&
            (identical(other.shipped, shipped) || other.shipped == shipped));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, id, type, message, paid, shipped);

  /// Create a copy of OrderStatusUpdate
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OrderStatusUpdateImplCopyWith<_$OrderStatusUpdateImpl> get copyWith =>
      __$$OrderStatusUpdateImplCopyWithImpl<_$OrderStatusUpdateImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$OrderStatusUpdateImplToJson(this);
  }
}

abstract class _OrderStatusUpdate implements OrderStatusUpdate {
  const factory _OrderStatusUpdate({
    required final String id,
    final int type,
    final String? message,
    required final bool paid,
    required final bool shipped,
  }) = _$OrderStatusUpdateImpl;

  factory _OrderStatusUpdate.fromJson(Map<String, dynamic> json) =
      _$OrderStatusUpdateImpl.fromJson;

  @override
  String get id; // order ID
  @override
  int get type; // message type: 2 = status update
  @override
  String? get message; // message to customer
  @override
  bool get paid; // has received payment
  @override
  bool get shipped;

  /// Create a copy of OrderStatusUpdate
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OrderStatusUpdateImplCopyWith<_$OrderStatusUpdateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

DeliveryAddress _$DeliveryAddressFromJson(Map<String, dynamic> json) {
  return _DeliveryAddress.fromJson(json);
}

/// @nodoc
mixin _$DeliveryAddress {
  String get street => throw _privateConstructorUsedError;
  String get city => throw _privateConstructorUsedError;
  String? get district => throw _privateConstructorUsedError;
  String? get postcode => throw _privateConstructorUsedError;
  String? get country => throw _privateConstructorUsedError;
  double? get lat => throw _privateConstructorUsedError;
  double? get lon => throw _privateConstructorUsedError;
  String? get notes => throw _privateConstructorUsedError;

  /// Serializes this DeliveryAddress to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DeliveryAddressCopyWith<DeliveryAddress> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DeliveryAddressCopyWith<$Res> {
  factory $DeliveryAddressCopyWith(
    DeliveryAddress value,
    $Res Function(DeliveryAddress) then,
  ) = _$DeliveryAddressCopyWithImpl<$Res, DeliveryAddress>;
  @useResult
  $Res call({
    String street,
    String city,
    String? district,
    String? postcode,
    String? country,
    double? lat,
    double? lon,
    String? notes,
  });
}

/// @nodoc
class _$DeliveryAddressCopyWithImpl<$Res, $Val extends DeliveryAddress>
    implements $DeliveryAddressCopyWith<$Res> {
  _$DeliveryAddressCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? street = null,
    Object? city = null,
    Object? district = freezed,
    Object? postcode = freezed,
    Object? country = freezed,
    Object? lat = freezed,
    Object? lon = freezed,
    Object? notes = freezed,
  }) {
    return _then(
      _value.copyWith(
            street: null == street
                ? _value.street
                : street // ignore: cast_nullable_to_non_nullable
                      as String,
            city: null == city
                ? _value.city
                : city // ignore: cast_nullable_to_non_nullable
                      as String,
            district: freezed == district
                ? _value.district
                : district // ignore: cast_nullable_to_non_nullable
                      as String?,
            postcode: freezed == postcode
                ? _value.postcode
                : postcode // ignore: cast_nullable_to_non_nullable
                      as String?,
            country: freezed == country
                ? _value.country
                : country // ignore: cast_nullable_to_non_nullable
                      as String?,
            lat: freezed == lat
                ? _value.lat
                : lat // ignore: cast_nullable_to_non_nullable
                      as double?,
            lon: freezed == lon
                ? _value.lon
                : lon // ignore: cast_nullable_to_non_nullable
                      as double?,
            notes: freezed == notes
                ? _value.notes
                : notes // ignore: cast_nullable_to_non_nullable
                      as String?,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DeliveryAddressImplCopyWith<$Res>
    implements $DeliveryAddressCopyWith<$Res> {
  factory _$$DeliveryAddressImplCopyWith(
    _$DeliveryAddressImpl value,
    $Res Function(_$DeliveryAddressImpl) then,
  ) = __$$DeliveryAddressImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    String street,
    String city,
    String? district,
    String? postcode,
    String? country,
    double? lat,
    double? lon,
    String? notes,
  });
}

/// @nodoc
class __$$DeliveryAddressImplCopyWithImpl<$Res>
    extends _$DeliveryAddressCopyWithImpl<$Res, _$DeliveryAddressImpl>
    implements _$$DeliveryAddressImplCopyWith<$Res> {
  __$$DeliveryAddressImplCopyWithImpl(
    _$DeliveryAddressImpl _value,
    $Res Function(_$DeliveryAddressImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? street = null,
    Object? city = null,
    Object? district = freezed,
    Object? postcode = freezed,
    Object? country = freezed,
    Object? lat = freezed,
    Object? lon = freezed,
    Object? notes = freezed,
  }) {
    return _then(
      _$DeliveryAddressImpl(
        street: null == street
            ? _value.street
            : street // ignore: cast_nullable_to_non_nullable
                  as String,
        city: null == city
            ? _value.city
            : city // ignore: cast_nullable_to_non_nullable
                  as String,
        district: freezed == district
            ? _value.district
            : district // ignore: cast_nullable_to_non_nullable
                  as String?,
        postcode: freezed == postcode
            ? _value.postcode
            : postcode // ignore: cast_nullable_to_non_nullable
                  as String?,
        country: freezed == country
            ? _value.country
            : country // ignore: cast_nullable_to_non_nullable
                  as String?,
        lat: freezed == lat
            ? _value.lat
            : lat // ignore: cast_nullable_to_non_nullable
                  as double?,
        lon: freezed == lon
            ? _value.lon
            : lon // ignore: cast_nullable_to_non_nullable
                  as double?,
        notes: freezed == notes
            ? _value.notes
            : notes // ignore: cast_nullable_to_non_nullable
                  as String?,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$DeliveryAddressImpl implements _DeliveryAddress {
  const _$DeliveryAddressImpl({
    required this.street,
    required this.city,
    this.district,
    this.postcode,
    this.country,
    this.lat,
    this.lon,
    this.notes,
  });

  factory _$DeliveryAddressImpl.fromJson(Map<String, dynamic> json) =>
      _$$DeliveryAddressImplFromJson(json);

  @override
  final String street;
  @override
  final String city;
  @override
  final String? district;
  @override
  final String? postcode;
  @override
  final String? country;
  @override
  final double? lat;
  @override
  final double? lon;
  @override
  final String? notes;

  @override
  String toString() {
    return 'DeliveryAddress(street: $street, city: $city, district: $district, postcode: $postcode, country: $country, lat: $lat, lon: $lon, notes: $notes)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DeliveryAddressImpl &&
            (identical(other.street, street) || other.street == street) &&
            (identical(other.city, city) || other.city == city) &&
            (identical(other.district, district) ||
                other.district == district) &&
            (identical(other.postcode, postcode) ||
                other.postcode == postcode) &&
            (identical(other.country, country) || other.country == country) &&
            (identical(other.lat, lat) || other.lat == lat) &&
            (identical(other.lon, lon) || other.lon == lon) &&
            (identical(other.notes, notes) || other.notes == notes));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    street,
    city,
    district,
    postcode,
    country,
    lat,
    lon,
    notes,
  );

  /// Create a copy of DeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DeliveryAddressImplCopyWith<_$DeliveryAddressImpl> get copyWith =>
      __$$DeliveryAddressImplCopyWithImpl<_$DeliveryAddressImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$DeliveryAddressImplToJson(this);
  }
}

abstract class _DeliveryAddress implements DeliveryAddress {
  const factory _DeliveryAddress({
    required final String street,
    required final String city,
    final String? district,
    final String? postcode,
    final String? country,
    final double? lat,
    final double? lon,
    final String? notes,
  }) = _$DeliveryAddressImpl;

  factory _DeliveryAddress.fromJson(Map<String, dynamic> json) =
      _$DeliveryAddressImpl.fromJson;

  @override
  String get street;
  @override
  String get city;
  @override
  String? get district;
  @override
  String? get postcode;
  @override
  String? get country;
  @override
  double? get lat;
  @override
  double? get lon;
  @override
  String? get notes;

  /// Create a copy of DeliveryAddress
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DeliveryAddressImplCopyWith<_$DeliveryAddressImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
